<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Virtual Scroll Table</title>
<style>
  table { border-collapse: collapse; width: 100%; }
  th, td { border: 1px solid #ccc; padding: 4px 8px; text-align: left; }
  th button { border: none; background: none; cursor: pointer; }
  tr.selected { background: #cde5ff; }
  .table-container {
    height: 300px; /* 可視範囲 */
    overflow-y: auto;
    position: relative;
    border: 1px solid #999;
    margin-top: 8px;
  }
  tbody { position: relative; }
  .spacer {
    height: 0;
  }
</style>
</head>
<body>

<table id="dataTable">
  <thead></thead>
</table>
<div class="table-container">
  <table>
    <tbody></tbody>
  </table>
</div>

<script>
// --- ダミーデータ生成 ---
const DATA = Array.from({ length: 2000 }, (_, i) => ({
  name: `User${i + 1}`,
  age: 20 + (i % 40),
  score: Math.floor(Math.random() * 100)
}));

// --- 列ごとのフィルター属性（外部から指定）---
const FILTER_TYPES = { name: "select", age: "range", score: "range" };

// --- 名前空間 ---
var TableFuncs = TableFuncs || {};

// --- 仮想スクロール対応クラス ---
TableFuncs.Table = class {
  constructor(tableId, data, filterTypes) {
    this.data = data;
    this.filtered = [...data];
    this.sorted = null;
    this.table = document.getElementById(tableId);
    this.thead = this.table.querySelector("thead");
    this.container = document.querySelector(".table-container");
    this.tbody = this.container.querySelector("tbody");
    this.rowHeight = 28;
    this.buffer = 10;
    this.columns = Object.keys(data[0]);
    this.filterValues = {};
    this.filterTypes = filterTypes;
    this.selectedRowIndex = 0;
    this.scrollTop = 0;

    this.renderHeader();
    this.renderFilterRow();
    this.applyFilterAndRender();
    this.setupScroll();
    this.setupKeyboard();
  }

  renderHeader() {
    const tr = document.createElement("tr");
    this.columns.forEach(col => {
      const th = document.createElement("th");
      const btn = document.createElement("button");
      btn.textContent = col;
      btn.addEventListener("click", () => this.sortBy(col));
      th.appendChild(btn);
      tr.appendChild(th);
    });
    this.thead.appendChild(tr);
  }

  renderFilterRow() {
    const tr = document.createElement("tr");
    this.columns.forEach(col => {
      const th = document.createElement("th");
      const type = this.filterTypes[col];
      if (type === "select") {
        const sel = document.createElement("select");
        sel.innerHTML = `<option value="">(すべて)</option>`;
        [...new Set(this.data.map(d => d[col]))].forEach(v => {
          const opt = document.createElement("option");
          opt.value = v;
          opt.textContent = v;
          sel.appendChild(opt);
        });
        sel.addEventListener("change", () => {
          this.filterValues[col] = sel.value;
          this.applyFilterAndRender();
        });
        th.appendChild(sel);
      } else if (type === "range") {
        const input = document.createElement("input");
        input.type = "text";
        input.placeholder = "min-max";
        input.addEventListener("change", () => {
          const [min, max] = input.value.split("-").map(Number);
          this.filterValues[col] = { min, max };
          this.applyFilterAndRender();
        });
        th.appendChild(input);
      }
      tr.appendChild(th);
    });
    this.thead.appendChild(tr);
  }

  sortBy(col) {
    const dir = (this.sorted?.key === col && this.sorted.dir === "asc") ? "desc" : "asc";
    this.sorted = { key: col, dir };
    this.filtered.sort((a, b) => {
      if (a[col] < b[col]) return dir === "asc" ? -1 : 1;
      if (a[col] > b[col]) return dir === "asc" ? 1 : -1;
      return 0;
    });
    this.renderVirtual();
    this.resetSelection();
    this.updateSortButtonState(col, dir);
  }

  updateSortButtonState(col, dir) {
    this.thead.querySelectorAll("button").forEach(btn => {
      btn.textContent = btn.textContent.replace(/ ↑| ↓/g, "");
      if (btn.textContent === col) btn.textContent += dir === "asc" ? " ↑" : " ↓";
    });
  }

  applyFilterAndRender() {
    this.filtered = this.data.filter(row => {
      return this.columns.every(col => {
        const f = this.filterValues[col];
        if (!f || f === "") return true;
        if (typeof f === "object") {
          const { min, max } = f;
          if (min && row[col] < min) return false;
          if (max && row[col] > max) return false;
          return true;
        }
        return row[col] == f;
      });
    });
    this.scrollTop = 0;
    this.container.scrollTop = 0;
    this.renderVirtual();
    this.resetSelection();
  }

  setupScroll() {
    this.container.addEventListener("scroll", () => {
      this.scrollTop = this.container.scrollTop;
      this.renderVirtual();
    });
  }

  renderVirtual() {
    const total = this.filtered.length;
    const visibleCount = Math.ceil(this.container.clientHeight / this.rowHeight);
    const startIndex = Math.floor(this.scrollTop / this.rowHeight);
    const endIndex = Math.min(total, startIndex + visibleCount + this.buffer);
    const slice = this.filtered.slice(startIndex, endIndex);

    this.tbody.innerHTML = "";

    const spacerTop = document.createElement("tr");
    spacerTop.className = "spacer";
    spacerTop.style.height = `${startIndex * this.rowHeight}px`;
    this.tbody.appendChild(spacerTop);

    slice.forEach((row, i) => {
      const tr = document.createElement("tr");
      this.columns.forEach(c => {
        const td = document.createElement("td");
        td.textContent = row[c];
        tr.appendChild(td);
      });
      const actualIndex = startIndex + i;
      tr.addEventListener("click", () => this.selectRow(actualIndex));
      if (actualIndex === this.selectedRowIndex) tr.classList.add("selected");
      this.tbody.appendChild(tr);
    });

    const spacerBottom = document.createElement("tr");
    spacerBottom.className = "spacer";
    spacerBottom.style.height = `${Math.max(0, (total - endIndex) * this.rowHeight)}px`;
    this.tbody.appendChild(spacerBottom);
  }

  setupKeyboard() {
    document.addEventListener("keydown", e => {
      if (["ArrowUp", "ArrowDown"].includes(e.key)) {
        e.preventDefault();
        const dir = e.key === "ArrowUp" ? -1 : 1;
        this.selectedRowIndex = Math.min(
          Math.max(0, this.selectedRowIndex + dir),
          this.filtered.length - 1
        );
        this.scrollToSelection();
        this.renderVirtual();
      }
    });
  }

  selectRow(index) {
    this.selectedRowIndex = index;
    this.scrollToSelection();
    this.renderVirtual();
  }

  scrollToSelection() {
    const y = this.selectedRowIndex * this.rowHeight;
    if (y < this.scrollTop) {
      this.container.scrollTop = y;
    } else if (y + this.rowHeight > this.scrollTop + this.container.clientHeight) {
      this.container.scrollTop = y - this.container.clientHeight + this.rowHeight;
    }
  }

  resetSelection() {
    this.selectedRowIndex = 0;
    this.renderVirtual();
  }
};

// --- 初期化 ---
document.addEventListener("DOMContentLoaded", () => {
  new TableFuncs.Table("dataTable", DATA, FILTER_TYPES);
});
</script>
</body>
</html>