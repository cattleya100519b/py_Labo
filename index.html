<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>TableApp（filter=match＋修正版）</title>
  <style>
    .table-container {
      height: 300px;
      overflow-y: auto;
      border: 1px solid #ccc;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      table-layout: fixed;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: 4px 8px;
      text-align: left;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    thead th {
      background: #fff;
      z-index: 3;
    }

    thead tr:nth-child(1) th {
      position: sticky;
      top: 0;
    }

    thead tr:nth-child(2) th {
      position: sticky;
      top: 30px;
      background: #f9f9f9;
      z-index: 2;
    }

    .sort-btn {
      margin-left: 5px;
      font-size: 12px;
    }

    tr.selected {
      background-color: #d0ebff;
    }

    .paging-controls {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 6px;
    }

    .filter-wrapper {
      display: flex;
      align-items: center;
      gap: 2px;
      position: relative;
    }

    .filter-btn {
      font-size: 10px;
      padding: 2px 5px;
    }

    .dropdown {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      display: none;
      max-height: 120px;
      overflow-y: auto;
      z-index: 10;
    }

    .dropdown div {
      padding: 2px 5px;
      cursor: pointer;
    }

    .dropdown div:hover {
      background: #e6f2ff;
    }

    .preview img {
      max-width: 200px;
      max-height: 200px;
      border: 1px solid #ccc;
    }

    #reset-filters {
      margin-bottom: 5px;
      font-size: 12px;
      padding: 3px 6px;
    }
  </style>
</head>

<body>

  <button id="reset-filters">フィルターリセット</button>

  <div class="table-container">
    <table id="data-table"></table>
  </div>

  <div class="paging-controls">
    <button id="prev-page">Prev</button>
    <input id="current-page" type="number" value="1" min="1" style="width:50px;"> /
    <span id="total-pages">1</span>
    <button id="next-page">Next</button>
    <select id="page-size">
      <option value="5">5</option>
      <option value="10" selected>10</option>
      <option value="20">20</option>
    </select> 件表示
  </div>

  <div class="preview">
    <img id="row-preview" src="" alt="Preview">
  </div>

  <script>
    const columns = [
      { key: "id", label: "ID" },
      { key: "name", label: "Name" },
      { key: "age", label: "Age" },
      { key: "score", label: "Score" },
      { key: "img", label: "Image" }
    ];

    const filterTypes = { id: "match", name: "match", age: "range", score: "range", img: "match" };

    const tableData = [];
    const names = ["Alice", "Bob", "Charlie", "David", "Eve"];
    for (let i = 1; i <= 50; i++) {
      const name = names[Math.floor(Math.random() * names.length)];
      const age = 18 + Math.floor(Math.random() * 50);
      const score = Math.floor(Math.random() * 100);
      tableData.push({ id: i, name, age, score, img: `img${(i % 5) + 1}.jpg` });
    }

    class TableApp {
      constructor(table, data, columns, filterTypes, pageSize = 10) {
        this.table = table;
        this.data = data;
        this.columns = columns;
        this.filterTypes = filterTypes;
        this.pageSize = pageSize;

        this.sortStates = {};
        this.filters = {};
        this.currentPage = 1;
        this.selectedIndex = 0;
        this.lastIndex = 0;
        this.imgPreview = document.getElementById("row-preview");

        this.renderHeader();
        this.initSort();
        this.initPaging();
        this.initRowSelect();
        this.initResetFilters();
        this.render();
      }

      renderHeader() {
        const thead = this.table.createTHead();

        const trHead = thead.insertRow();
        this.columns.forEach(col => {
          const th = document.createElement("th");
          th.textContent = col.label;
          const btn = document.createElement("button");
          btn.className = "sort-btn";
          btn.dataset.key = col.key;
          btn.textContent = "△▽";
          th.appendChild(btn);
          trHead.appendChild(th);
          this.sortStates[col.key] = "none";
        });

        const trFilter = thead.insertRow();
        this.columns.forEach(col => {
          const th = document.createElement("th");
          const type = this.filterTypes[col.key] || "match";

          if (type === "range") {
            const min = document.createElement("input");
            const max = document.createElement("input");
            min.type = max.type = "number";
            min.placeholder = "Min";
            max.placeholder = "Max";
            min.style.width = max.style.width = "40%";
            min.oninput = max.oninput = () => {
              this.filters[col.key] = {
                ...this.filters[col.key],
                min: Number(min.value) || null,
                max: Number(max.value) || null
              };
              this.currentPage = 1;
              this.render();
            };
            th.append(min, document.createTextNode(" - "), max);
          } else {
            const wrapper = document.createElement("div");
            wrapper.className = "filter-wrapper";
            const input = document.createElement("input");
            input.type = "text";
            input.placeholder = "Filter";
            input.oninput = () => {
              this.filters[col.key] = { text: input.value || null };
              this.currentPage = 1;
              this.render();
            };
            wrapper.appendChild(input);

            const btn = document.createElement("button");
            btn.textContent = "▼";
            btn.className = "filter-btn";
            wrapper.appendChild(btn);

            const dropdown = document.createElement("div");
            dropdown.className = "dropdown";
            document.body.appendChild(dropdown);

            btn.onclick = (e) => {
              e.stopPropagation();
              dropdown.innerHTML = "";
              const rect = btn.getBoundingClientRect();
              dropdown.style.left = rect.left + "px";
              dropdown.style.top = rect.bottom + "px";
              const uniqueValues = [...new Set(this.data.map(d => d[col.key]))];
              uniqueValues.forEach(v => {
                const div = document.createElement("div");
                div.textContent = v;
                div.onclick = () => {
                  input.value = v;
                  this.filters[col.key] = { text: v };
                  dropdown.style.display = "none";
                  this.currentPage = 1;
                  this.render();
                };
                dropdown.appendChild(div);
              });
              dropdown.style.display = "block";
            };
            document.addEventListener("click", () => dropdown.style.display = "none");
            th.appendChild(wrapper);
          }
          trFilter.appendChild(th);
        });
      }

      initSort() {
        this.table.querySelectorAll(".sort-btn").forEach(btn => {
          btn.addEventListener("click", () => {
            const key = btn.dataset.key;
            const current = this.sortStates[key];
            const next = current === "none" ? "asc" : current === "asc" ? "desc" : "none";
            Object.keys(this.sortStates).forEach(k => this.sortStates[k] = "none");
            this.sortStates[key] = next;
            this.updateSortIcons();
            this.currentPage = 1;
            this.render();
          });
        });
      }

      updateSortIcons() {
        this.table.querySelectorAll(".sort-btn").forEach(btn => {
          const state = this.sortStates[btn.dataset.key];
          btn.textContent = state === "none" ? "△▽" : state === "asc" ? "▲▽" : "△▼";
        });
      }

      initPaging() {
        const prev = document.getElementById("prev-page");
        const next = document.getElementById("next-page");
        const cur = document.getElementById("current-page");
        const total = document.getElementById("total-pages");
        const size = document.getElementById("page-size");

        prev.onclick = () => {
          const totalPages = Math.ceil(this.filtered.length / this.pageSize) || 1;
          this.currentPage = (this.currentPage - 2 + totalPages) % totalPages + 1;
          this.render();
        };
        next.onclick = () => {
          const totalPages = Math.ceil(this.filtered.length / this.pageSize) || 1;
          this.currentPage = this.currentPage % totalPages + 1;
          this.render();
        };
        cur.onchange = () => {
          const totalPages = Math.ceil(this.filtered.length / this.pageSize) || 1;
          this.currentPage = Math.min(Math.max(1, +cur.value), totalPages);
          this.render();
        };
        size.onchange = () => {
          this.pageSize = +size.value;
          this.currentPage = 1;
          this.render();
        };
        this.pageUI = { cur, total };
      }

      initRowSelect() {
        this.table.addEventListener("click", e => {
          const tr = e.target.closest("tr");
          if (!tr) return;
          const idx = [...this.table.tBodies[0].rows].indexOf(tr);
          this.selectedIndex = idx;
          this.updateSelection(0);
        });

        document.addEventListener("keydown", e => {
          if (!this.pageRows?.length) return;
          const rows = this.table.tBodies[0].rows;
          if (e.key === "ArrowDown") {
            const lastIndex = this.selectedIndex;
            this.selectedIndex = (this.selectedIndex + 1) % this.pageRows.length;
            this.updateSelection(lastIndex);
          } else if (e.key === "ArrowUp") {
            const lastIndex = this.selectedIndex;
            this.selectedIndex = (this.selectedIndex - 1 + this.pageRows.length) % this.pageRows.length;
            this.updateSelection(lastIndex);
          }
        });
      }

      updateSelection(lastIndex) {
        const rows = this.table.tBodies[0].rows;
        [...rows].forEach((r, i) => r.classList.toggle("selected", i === this.selectedIndex));
        const sel = this.pageRows[this.selectedIndex];
        if (sel && this.imgPreview) this.imgPreview.src = sel.img || "";

        const container = document.querySelector(".table-container");

        // 固定ヘッダ高さ
        const thead = this.table.tHead;
        let headerHeight = 0;
        if (thead) [...thead.rows].forEach(r => headerHeight += r.offsetHeight);

        // 行末→行頭, 行頭→行末ループ
        if (this.selectedIndex === 0 && lastIndex === rows.length - 1) {
          container.scrollTop = 0;
        } else if (this.selectedIndex === rows.length - 1 && lastIndex === 0) {
          container.scrollTop = container.scrollHeight;
        } else {
          // ページ内スクロール補正
          const rowTop = rows[this.selectedIndex].offsetTop;
          const rowBottom = rowTop + rows[this.selectedIndex].offsetHeight;
          const viewTop = container.scrollTop;
          const viewBottom = viewTop + container.clientHeight;

          if (rowBottom > viewBottom) {
            container.scrollTop += rows[this.selectedIndex].offsetHeight;
          } else if (rowTop < viewTop + headerHeight) {
            container.scrollTop -= rows[this.selectedIndex].offsetHeight;
          }
        }

        this.lastIndex = this.selectedIndex;
      }

      initResetFilters() {
        document.getElementById("reset-filters").onclick = () => {
          this.filters = {};
          document.querySelectorAll("thead input").forEach(el => el.value = "");
          this.currentPage = 1;
          this.render();
        };
      }

      render() {
        this.filtered = this.data.filter(d =>
          this.columns.every(col => {
            const f = this.filters[col.key];
            if (!f) return true;
            const val = d[col.key];
            if (f.text != null) return String(val).toLowerCase().includes(f.text.toLowerCase());
            if (f.min != null && val < f.min) return false;
            if (f.max != null && val > f.max) return false;
            return true;
          })
        );

        const sortKey = Object.keys(this.sortStates).find(k => this.sortStates[k] !== "none");
        if (sortKey) {
          const order = this.sortStates[sortKey];
          this.filtered.sort((a, b) => {
            const va = a[sortKey], vb = b[sortKey];
            const num = !isNaN(va) && !isNaN(vb);
            if (num) return order === "asc" ? va - vb : vb - va;
            return order === "asc"
              ? String(va).localeCompare(String(vb))
              : String(vb).localeCompare(String(va));
          });
        }

        const totalPages = Math.ceil(this.filtered.length / this.pageSize) || 1;
        if (this.currentPage > totalPages) this.currentPage = totalPages;

        const start = (this.currentPage - 1) * this.pageSize;
        const end = start + this.pageSize;
        this.pageRows = this.filtered.slice(start, end);

        if (!this.table.tBodies[0]) this.table.appendChild(document.createElement("tbody"));
        const tbody = this.table.tBodies[0];
        tbody.innerHTML = "";

        this.pageRows.forEach(d => {
          const tr = document.createElement("tr");
          this.columns.forEach(c => {
            const td = document.createElement("td");
            td.textContent = d[c.key];
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });

        this.selectedIndex = 0;
        this.lastIndex = 0;
        this.updateSelection(0);
        this.pageUI.cur.value = this.currentPage;
        this.pageUI.total.textContent = totalPages;
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      new TableApp(document.getElementById("data-table"), tableData, columns, filterTypes, 10);
    });
  </script>
</body>

</html>